#pragma once
#include <vector>
#include <algorithm>
#include <sstream>
using namespace std;
///////////////////////////////////////////////////////////////////////////////
// Population class :    Note that the .h and .cpp file as generated by visual
// are combined in this single .h file.  This is required in visual since the
// compiler cannot split them when template typing is being used.  I am not
// sure why this is the case since it should be possible to separate them.
// The main reason I have templated this class is that it will allow us to
// use it with different genomes(chromosomes) without changeing the code in
// this class.
/////////////////////////////////////////////////////////////////////////////
enum SelectionType { TOURNAMENT, ROULETTE, RANK };
enum StatRequest { ALL, BEST };
using namespace std;
template<typename genomeType>
class Population
{
	// This container holds the genomes in the population
	// as well as their associated fitnesses
	vector<genomeType> Pop;
	int pop_size;// This should always be even
	double RankTotal_fitness;
	int best_index; // index of the best chromosome in the population.
	double best_fitness;//The UpdateStats method sets this.
	double Total_fitness;//The UpdateStats method sets this.
	bool elitism;// if this is true then copy the best genome over to the new pop twice
public:
	Population();
	Population(int size);
	~Population();
	void GeneratePopulation(int size);// Generates the first population
	void Dump(int, bool);// DEBUGGING :Dumps the stats for the present population.
	double AveFitness();
	void UpdateStats();// Recalulates the populations Stats.
	double BestFitness();// This method returns the best fitness of the population
	void PopulationSort();
	genomeType Selection(SelectionType);// Returns a selected genome.
	int BestIndex();
	void SetElitism(bool);
	bool CriteriaMet();
	void InsertGenome(genomeType genome);
	// sr is either ALL or BEST
	string GetStats(StatRequest sr)
	{
		stringstream ss;
		ss << "Genetic Algorithm Statistics";
		if (elitism)
			ss << "(with Elitism)" << endl;
		else ss << endl;
		if (sr == ALL || BEST)
			ss << "Best individual is " << Pop[best_index] << " with fitness = " << Pop[best_index].fitness << endl;

		if (sr == ALL) {
			ss << "Final population genomes and their associated fitness" << endl;
			for (int i = 0; i < pop_size; i++)
				ss << Pop[i] << "      " << Pop[i].fitness << endl;
		}
		return ss.str();
	}

	genomeType BestGenome()
	{
		return Pop[best_index];
	}
};

// This compare operation is needed for the sort in RANK

struct Compare {
	template<typename genomeType>
	bool operator()(genomeType a, genomeType b)
	{
		return(a.fitness < b.fitness);
	}
};

template<typename genomeType>
void Population<genomeType>::PopulationSort()
{
	sort(Pop.begin(), Pop.end(), Compare());
}

template<typename genomeType>
Population<genomeType>::Population(int size)
{
	pop_size = size;
	RankTotal_fitness = size*(size + 1) / 2;
}
template<typename genomeType>
Population<genomeType>::Population()
{
	elitism = false;
}


template<typename genomeType>
Population<genomeType>::~Population()
{
}

template<typename genomeType>
double Population<genomeType>::AveFitness()
{
	double sum = 0;
	for (int i = 0; i < Pop.size(); i++)
		sum += Pop[i].fitness;
	return (sum / Pop.size());

}
//////////////////////////////////////////////////////////////////
// This method determines a stopping criteria.  The criteria may be
// either a certain chromosome criteria() or an attribute of the pop
// as a whole. 
//////////////////////////////////////////////////////////////////
template<typename genomeType>
bool Population<genomeType>::CriteriaMet()
{
	for (int i = 0; i < Pop.size(); i++)
		if (Pop[i].Criteria())return true;// check chromosome criteria
	return false;
	// We can also check the entire population for some other attribute
	// such as deviation or diversity.. Diversity is usually more time consuming
}

//////////////////////////////////////////////////////////////////////
// This method is called to build the initial population of a given
// size.  A population is just a vector of chroms.  Each chromosome
// has its fitness included in the structure. It also calcualtes the best 
// fitness and associated chromosome.
/////////////////////////////////////////////////////////////////////
template<typename genomeType>
void Population<genomeType>::GeneratePopulation(int size)
{
	RankTotal_fitness = (size*(size + 1) / 2.0);// only need to calculate once for Ranking
												// Generate population of size POP_SIZE
	if (size % 2 == 1) {
		cout << "Error: Population size should be even" << endl;
		exit(1);
	}
	Total_fitness = 0.0;
	pop_size = size;// Store in an attribute var
	best_fitness = -100;
	for (int i = 0; i < pop_size; i++) {
		genomeType genome; // default constructor generates a random chrom.
		genome.UpdateFitness();
		Total_fitness += genome.fitness;
		if (genome.fitness > best_fitness) {
			best_fitness = genome.fitness;
			best_index = i;
		}
		Pop.push_back(genome);// Add this chrom to the population
	}
}

/////////////////////////////////////////////////////////////////////////
// This method is used to dump the statistics association with the present
// generation.  The generation number, gen,  is sent in for display only.
////////////////////////////////////////////////////////////////////////
template<typename genomeType>
void Population<genomeType>::Dump(int gen, bool pop_dump)
{
	cout << "-------POPULATION DUMP------- " << endl;
	cout << "Generation " << gen << endl;
	cout << "Best individual is " << Pop[best_index] << " : fitness = " << Pop[best_index].fitness << endl;
	//cout << "Total_fitness is " << Total_fitness << endl;
	if (pop_dump) {// print the population out
		std::cout << "Genomes and their associated Fitness" << endl;
		for (int i = 0; i < pop_size; i++)
			cout << Pop[i] << "      " << Pop[i].fitness << endl;
	}
	cout << "---------END OF DUMP---------" << endl;
}


////////////////////////////////////////////////////////////////
// This method updates all the statistics that you have included
// in your algorithm.  At the moment it just calculates the best
// fitness of the chromosomes in the population. The index of the
// best chromosome is placed in best_index and its fitness is 
// placed in best_fitness.  
////////////////////////////////////////////////////////////////
template<typename genomeType>
void Population<genomeType>::UpdateStats()
{
	Total_fitness = 0.0;
	pop_size =(int) Pop.size();
	best_fitness = -10000.0;//fix this
	for (int i = 0; i < pop_size; i++) {
		Total_fitness += Pop[i].fitness;
		if (Pop[i].fitness > best_fitness) {
			best_fitness = Pop[i].fitness;
			best_index = i;
		}
	}
}

template<typename genomeType>
double Population<genomeType>::BestFitness()
{
	return best_fitness;
}

template<typename genomeType>
void Population<genomeType>::InsertGenome(genomeType genome)
{
	Pop.push_back(genome);// Add this chrom to the population
}


template<typename genomeType>
genomeType Population<genomeType>::Selection(SelectionType seltype)
{
	int index, index1, index2;
	double sel_fit, run_fit = 0;
	switch (seltype) {
	case ROULETTE://Proportional Roulette wheel selection
		run_fit = 0;
		index = 0;
		sel_fit = Total_fitness*(rand() / (double)RAND_MAX);
		// find the index for this chromosome
		run_fit = Pop[index].fitness; // Get fitness of first chromosome in the population
									  // add the fitness of the chromosomes until we get the sel_fit
		while (run_fit < sel_fit && index < pop_size - 1) {
			index++;
			run_fit += Pop[index].fitness;
		}
		break;
	case RANK://Rank selection. The pop must be sorted from small to large
			  // for this to work properly.  Sort is in
			  //RankTotal_fitness = (30*(30 + 1) / 2.0);
		index = 0;
		// The ranktotal here is n*(n+1)/2 where n = pop size
		sel_fit = RankTotal_fitness*(rand() / (double)RAND_MAX);
		// find the index for this chromosome 
		run_fit = 1; // Get fitness of first chromosome in the population
					 // add the rank fitness of the chromosomes until we get the sel_fit
		while (run_fit < sel_fit && index < pop_size) {
			index++;// The fitness of the next individual
			run_fit += index + 1;
		}
		break;
	case TOURNAMENT:
		// Pick two genomes randomly
		index1 = rand() % pop_size;
		index2 = rand() % pop_size;
		if (Pop[index1].fitness > Pop[index2].fitness)
			index = index1;
		else
			index = index2;
		break;
	}
	return Pop[index];
}

template<typename genomeType>
int Population<genomeType>::BestIndex()
{
	return best_index;
}

template<typename genomeType>
void Population<genomeType>::SetElitism(bool e)
{
	elitism = e;
}
